---
layout: post
title: "CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"
categories: [ceph, 翻译]
tags: git
---

* 目录
{:toc}

## 摘要
新兴的大规模分布式存储系统，是为解决PB级的数据分散的存放在成千上万个存储设备上的问题。类似的系统需要保证系统扩展和管理硬件错误的同时，还要平均的分布数据和负载，从而有效的使用资源和最大化系统性能。我们开发了CRUSH，一个为分布式对象存储系统设计的可扩展伪随机数分布函数，可以不依赖中心目录高效映射数据对象到存储设备上。由于大系统天生的变化特性，CRUSH设计处理添加或移除存储时，尽量最小化不必要的数据移动。这个算法适用于各种数据副本和可靠性机制，也适用于将数据副本分布到不同容错域的用户自定义数据分布策略。

## 介绍
基于对象的存储是一种可提高可管理性、可扩展性和性能的新兴架构。与传统基于块的磁盘不同，基于对象的存储设备（OSDs，object-based storage devices）内部管理磁盘块分配，对外暴露叫做对象的接口，允许不同大小的读写。在这样的系统中，每个文件的数据被分成较小的对象，分布在整个存储集群中。为了防止错误时导致数据丢失，对象在多个设备上存有副本（或者其它的数据冗余方式）。基于对象的存储系统，通过用小的对象列表替换大的块列表和分散底层块分配问题，简化数据布局（layout）。尽管这样可极大提高可扩展性，减少文件分配的元数据和降低复杂度，但将数据分布到大量不同容量和性能存储设备的基本工作依然存在。
大部分系统只是简单的写入新数据的方式不充分利用设备，这种方式解决的是数据一旦写入就很少移动的问题。存储扩容时，即使完美的分布式系统，也会变得平衡，因为新磁盘要么是空的，要么只包含新数据。大部分情况下，只有新的或老的磁盘处于忙的状态，具体与系统负载有关。
一个健壮的解决方案是将系统的所有数据都随机分布到可用的存储设备上，新老数据混合在一起就有可能平衡分布。当新设备添加时，一部分现有的数据迁移到新存储上回复平衡。这种方式最大的好处就是，所有设备都保持相似的负载，系统处于任何负载时都可以良好的运作。除此之外，在大的存储系统之中，单个的大文件会被随机的分布到多个设备上，可以提供更高的并发度和汇聚带宽。然而，简单的哈希分布在设备数量变化时会有问题，大致大量的数据抖动。现有的副本随机分布方法，在设备出现一致性错误时，有很高的数据丢失风险。
我们开发的CRUSH（Controlled Replication Under Scalable Hashing），一个可以高效健壮的将对象副本分散到异构的结构化存储集群中的伪随机数据分布算法。CRUSH是一个实现的一致性伪随机函数，输入值通常是一个对象或对象组标识符（object group identifier），映射到存放对象副本的设备列表。与传统的实现不同之处在于，数据的位置不依赖于任何类型的文件或对象目录，CRUSH只需要一个简洁的存储设备拓扑结构描述和副本位置策略。这种方式有2个关键优势：首先，是完全分布式，大系统的任何参与部分都可独立计算任何对象的位置；其次，需要的元数据很少且基本固定，仅在设备添加或删除时改变。
CRUSH设计考虑了数据分布充分利用可用资源，存储设备添加删除时高效重组数据，通过灵活的副本位置限制最大化硬件故障或其它意外发生时的数据安全性。支持各种各样的数据安全机制，包括多路复制（镜像）、RAID奇偶校验或其它校验码。这些特性使CRUSH适用于在对扩展性、性能和可靠性都很关键的超大规模（几PB）存储系统中管理对象分布。

## 相关工作
基于对象的存储作为提高存储系统扩展性的一种方法，最近获得不少关注。很多研究和生产环境的文件系统都使用基于对象的方式，包括开创性的NASD文件系统、Pnasas文件系统、Lustre等。其它基于块的分布式文件系统，如GPFS和FAB也面临类似的数据分布问题。在这些系统中，使用半随机或启发式的方法在可用的存储上分配新数据，但很少重新分配保持分布的平衡。更重要的是，所有这些系统都通过某种元数据目录定位数据，而CRUSH只是依赖于简洁的集群描述和特定的映射函数。在写数据时，系统通过CRUSH可以计算任何新数据的存储位置，而不需要查询中心分配器，这才是最大的区别。Storento存储系统使用的一致性哈希与CRUSH最相似，但缺少平衡数据分布的设备权重和提高数据安全的容错域支持。
尽管数据迁移问题在显示分配映射系统中被大量的研究过，但类似实现都需要大量元数据，而CRUSH没有。Choy在描述数据在磁盘间分布的算法中，在磁盘添加时会移动部分对象，但不支持权重、复制或磁盘删除。Brinkmann用哈希函数分布数据到异构系统中，但只是静态集群。SCADDAR提到了存储添加和删除，但只支持特定的副本策略。他们都没有CRUSH的灵活性和提高可靠性的容错域。

## CRUSH算法
CRUSH算法根据每个设备权重值在存储中分布数据对象，尽可能的达到概率统一。分布由表示可用资源和组成的逻辑元素拓扑映射控制。如，一个大规模部署包括很多排服务器机柜，机柜中有硬盘架，硬盘架里有存储设备。数据分布策略在位置规则（*placement rules*）中定义，包括几个目标副本以及副本存放的限制。如，3个镜像副本放在不同物理机柜的设备上，他们使用不同的电源。
给一个整型输入值x，CRUSH输出一个表示n个存储目标的有序列表R。CRUSH使用参数包括x的多整型输入哈希函数，仅使用集群拓扑描述表、位置规则和x让映射完全确定且可计算。分布是伪随机的，从相似的输入得到的输出结果没有明显的关联性。我们称CRUSH产生伪集群（*declustered*）副本分布，输出的这组设备共享数据副本，但彼此又表现出无关联性。

### 集群拓扑映射
集群映射（cluster map）由设备（devices）和桶（buckets）组成，他们都有数字描述符和权重值。桶可以包含任意数量的设备或其它的桶，允许他们在存储拓扑结构中形成内部节点，设备总是叶节点。给存储设备分配权重是为了管理他们需要负责存储的相对数据量。尽管大型系统中包含各种不同容量和性能的设备，数据随机分布时的统计显示设备使用率与负载有关，也就是说设备平均负载与存储的数据量是成比例的。这就产生了一个位置标准，权重，应该由设备容量来。桶的权重定义为它包含的所有项的权重之和。
桶可以由存储拓扑中的任何元素组成，如，在最底层用硬盘架（shelf）桶表示一组相同的硬盘，然后用机柜（cabinet）桶将放在一起的硬盘架组合在一起。机柜还可以再组成排（row）或机房（room）桶，表示整个大系统。通过伪随机哈希函数递归选择嵌套的桶元素，最终决定数据存放的位置。与传统的哈希技术在目标（设备）数量变化时，就会产生大量数据抖动相比，CRUSH基于4个不同的桶类型，每个都对应不同的数据移动算法和计算复杂度。

### 副本位置

CRUSH设计的目的就是要让数据分布在设备上，达到存储利用率和设备带宽资源的平衡。副本在存储拓扑中的位置也会对数据安全性造成极大影响。根据安装时的底层物理架构，CRUSH可以建模，进而定位与设备错误相关的潜在问题源。典型的包括，相近物理设备、共用电源和共享网络。通过将这些信息编码到集群映射表（cluster map）中，CRUSH位置策略可以将对象副本放到不同的容错域中，同时保持需要的分布。如，为了定位并发错误的发生，需要保证数据副本在不同的机架、机柜、电源、控制器或物理位置。
为了适应各种不同的应用场景，包括数据副本策略和底层硬件配置，CRUSH为每个副本策略定义了位置规则，让系统或管理员可以精确指定对象副本的位置。如，为2个副本选择两个存储目标，为3个副本在2个数据中心选择3个存储目标。
算法1的伪代码，在简单的执行环境中，每个规则由一系列应用到的操作组成。

![算法1](../images/crush-alg1.jpg)

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
\\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\\)
\\(vec i\\)

















